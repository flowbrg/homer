# streamlit_app.py
import streamlit as st
import time
from typing import List, Dict, Any
import asyncio
from datetime import datetime

# Import your existing modules
from src.core.application import Application
from src.core.configuration import Configuration
from src.core import database
from src.resources.utils import load_config
from langchain_core.messages import AIMessage, HumanMessage

# Configure Streamlit page
st.set_page_config(
    page_title="AI Chat Assistant",
    page_icon="🤖",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Custom CSS for better styling
st.markdown("""
<style>
    .main-header {
        font-size: 2.5rem;
        font-weight: 700;
        color: #1f2937;
        text-align: center;
        margin-bottom: 2rem;
    }
    
    .chat-container {
        max-height: 600px;
        overflow-y: auto;
        padding: 1rem;
        border: 1px solid #e5e7eb;
        border-radius: 0.5rem;
        background-color: #f9fafb;
    }
    
    .user-message {
        background: linear-gradient(135deg, #3b82f6, #1d4ed8);
        color: white;
        padding: 1rem;
        border-radius: 1rem;
        margin: 0.5rem 0;
        margin-left: 20%;
        position: relative;
    }
    
    .assistant-message {
        background: white;
        color: #374151;
        padding: 1rem;
        border-radius: 1rem;
        margin: 0.5rem 0;
        margin-right: 20%;
        border: 1px solid #e5e7eb;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }
    
    .message-time {
        font-size: 0.75rem;
        opacity: 0.7;
        margin-top: 0.5rem;
    }
    
    .thread-item {
        padding: 0.75rem;
        margin: 0.25rem 0;
        border-radius: 0.5rem;
        cursor: pointer;
        transition: all 0.2s;
    }
    
    .thread-item:hover {
        background-color: #f3f4f6;
    }
    
    .thread-item-active {
        background: linear-gradient(135deg, #3b82f6, #1d4ed8);
        color: white;
    }
    
    .typing-indicator {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        padding: 1rem;
        color: #6b7280;
        font-style: italic;
    }
    
    .dot {
        height: 8px;
        width: 8px;
        background-color: #6b7280;
        border-radius: 50%;
        animation: pulse 1.5s ease-in-out infinite;
    }
    
    .dot:nth-child(2) { animation-delay: 0.1s; }
    .dot:nth-child(3) { animation-delay: 0.2s; }
    
    @keyframes pulse {
        0%, 60%, 100% { transform: scale(1); opacity: 1; }
        30% { transform: scale(1.1); opacity: 0.7; }
    }
    
    .stButton > button {
        width: 100%;
        background: linear-gradient(135deg, #3b82f6, #1d4ed8);
        color: white;
        border: none;
        padding: 0.75rem 1.5rem;
        border-radius: 0.5rem;
        font-weight: 600;
        transition: all 0.2s;
    }
    
    .stButton > button:hover {
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
    }
</style>
""", unsafe_allow_html=True)

# Initialize session state
def initialize_session_state():
    """Initialize Streamlit session state variables."""
    if 'app' not in st.session_state:
        config = load_config()
        st.session_state.app = Application(config)
    
    if 'current_thread_id' not in st.session_state:
        st.session_state.current_thread_id = None
    
    if 'messages' not in st.session_state:
        st.session_state.messages = []
    
    if 'threads' not in st.session_state:
        st.session_state.threads = []
    
    if 'is_streaming' not in st.session_state:
        st.session_state.is_streaming = False

def load_threads():
    """Load all chat threads from database."""
    threads = database.get_all_threads()
    st.session_state.threads = [{"id": thread_id, "name": thread_name} for thread_id, thread_name in threads]

def load_messages(thread_id: int):
    """Load messages for a specific thread."""
    if thread_id is None:
        st.session_state.messages = []
        return
    
    messages = st.session_state.app.get_messages(thread_id)
    st.session_state.messages = []
    
    for msg in messages:
        if isinstance(msg, HumanMessage):
            st.session_state.messages.append({
                "role": "user",
                "content": msg.content,
                "timestamp": datetime.now()
            })
        elif isinstance(msg, AIMessage):
            st.session_state.messages.append({
                "role": "assistant", 
                "content": msg.content,
                "timestamp": datetime.now()
            })

def create_new_thread(thread_name: str):
    """Create a new chat thread."""
    if not thread_name.strip():
        st.error("Le nom du thread ne peut pas être vide")
        return
    
    existing_threads = database.get_all_threads()
    new_id = (existing_threads[-1][0] + 1) if existing_threads else 1
    
    database.new_thread(thread_id=new_id, thread_name=thread_name.strip())
    load_threads()
    st.session_state.current_thread_id = new_id
    load_messages(new_id)
    st.success(f"Nouveau thread '{thread_name}' créé!")
    st.rerun()

def delete_thread(thread_id: int):
    """Delete a chat thread."""
    database.delete_thread(thread_id)
    load_threads()
    
    if st.session_state.current_thread_id == thread_id:
        st.session_state.current_thread_id = None
        st.session_state.messages = []
    
    st.success("Thread supprimé!")
    st.rerun()

def select_thread(thread_id: int):
    """Select and load a thread."""
    st.session_state.current_thread_id = thread_id
    load_messages(thread_id)

def stream_response(query: str, thread_id: int):
    """Stream AI response and update messages in real-time."""
    if not query.strip() or thread_id is None:
        return
    
    # Add user message immediately
    st.session_state.messages.append({
        "role": "user",
        "content": query,
        "timestamp": datetime.now()
    })
    
    # Create placeholder for AI response
    ai_message = {
        "role": "assistant",
        "content": "",
        "timestamp": datetime.now()
    }
    st.session_state.messages.append(ai_message)
    
    # Create a container for the streaming response
    response_container = st.empty()
    
    try:
        st.session_state.is_streaming = True
        full_response = ""
        
        # Stream the response
        for token in st.session_state.app.stream_retrieval_graph(query=query, thread_id=thread_id):
            full_response += token
            st.session_state.messages[-1]["content"] = full_response
            
            # Update the display in real-time
            with response_container.container():
                display_messages()
            
            time.sleep(0.01)  # Small delay for smoother streaming effect
        
        st.session_state.is_streaming = False
        
    except Exception as e:
        st.session_state.is_streaming = False
        st.session_state.messages[-1]["content"] = f"Erreur: {str(e)}"
        st.error(f"Erreur lors de la génération de la réponse: {str(e)}")

def display_messages():
    """Display all messages in the chat."""
    for i, message in enumerate(st.session_state.messages):
        timestamp = message.get("timestamp", datetime.now()).strftime("%H:%M")
        
        if message["role"] == "user":
            st.markdown(f"""
            <div class="user-message">
                <strong>Vous:</strong><br>
                {message["content"]}
                <div class="message-time">{timestamp}</div>
            </div>
            """, unsafe_allow_html=True)
        else:
            # Convert basic markdown for AI messages
            content = message["content"]
            content = content.replace("**", "<strong>").replace("**", "</strong>")
            content = content.replace("*", "<em>").replace("*", "</em>")
            content = content.replace("\n", "<br>")
            
            st.markdown(f"""
            <div class="assistant-message">
                <strong>🤖 Assistant:</strong><br>
                {content}
                <div class="message-time">{timestamp}</div>
            </div>
            """, unsafe_allow_html=True)

def main():
    """Main application function."""
    # Initialize
    initialize_session_state()
    load_threads()
    
    # Header
    st.markdown('<h1 class="main-header">🤖 AI Chat Assistant</h1>', unsafe_allow_html=True)
    
    # Sidebar for thread management
    with st.sidebar:
        st.header("💬 Conversations")
        
        # New thread creation
        with st.expander("➕ Nouvelle conversation", expanded=False):
            new_thread_name = st.text_input("Nom de la conversation:", placeholder="Ex: Aide Python")
            col1, col2 = st.columns(2)
            with col1:
                if st.button("Créer", key="create_thread"):
                    create_new_thread(new_thread_name)
            with col2:
                if st.button("Annuler", key="cancel_create"):
                    st.rerun()
        
        # Thread list
        st.subheader("📋 Conversations existantes")
        
        if not st.session_state.threads:
            st.info("Aucune conversation. Créez-en une nouvelle!")
        else:
            for thread in st.session_state.threads:
                col1, col2 = st.columns([3, 1])
                
                with col1:
                    is_active = st.session_state.current_thread_id == thread["id"]
                    button_type = "primary" if is_active else "secondary"
                    
                    if st.button(
                        f"💬 {thread['name']}", 
                        key=f"thread_{thread['id']}", 
                        type=button_type,
                        use_container_width=True
                    ):
                        select_thread(thread["id"])
                        st.rerun()
                
                with col2:
                    if st.button("🗑️", key=f"delete_{thread['id']}", help="Supprimer"):
                        if st.session_state.get(f"confirm_delete_{thread['id']}", False):
                            delete_thread(thread["id"])
                        else:
                            st.session_state[f"confirm_delete_{thread['id']}"] = True
                            st.warning("Cliquez à nouveau pour confirmer")
                            st.rerun()
        
        # Settings section
        with st.expander("⚙️ Paramètres", expanded=False):
            st.info("Configuration de l'application")
            if st.button("Recharger l'application"):
                st.cache_data.clear()
                st.rerun()
    
    # Main chat area
    if st.session_state.current_thread_id is None:
        st.info("👈 Sélectionnez une conversation dans la barre latérale ou créez-en une nouvelle pour commencer!")
    else:
        # Display current thread name
        current_thread = next(
            (t for t in st.session_state.threads if t["id"] == st.session_state.current_thread_id), 
            None
        )
        if current_thread:
            st.subheader(f"💬 {current_thread['name']}")
        
        # Chat display area
        chat_container = st.container()
        
        with chat_container:
            if st.session_state.messages:
                display_messages()
            else:
                st.info("Commencez une nouvelle conversation en tapant votre message ci-dessous!")
        
        # Streaming indicator
        if st.session_state.is_streaming:
            st.markdown("""
            <div class="typing-indicator">
                L'assistant tape
                <div class="dot"></div>
                <div class="dot"></div>
                <div class="dot"></div>
            </div>
            """, unsafe_allow_html=True)
        
        # Input area
        st.markdown("---")
        
        # Message input
        user_input = st.text_area(
            "Votre message:",
            placeholder="Tapez votre message ici...",
            height=100,
            disabled=st.session_state.is_streaming,
            key="user_input"
        )
        
        col1, col2, col3 = st.columns([1, 2, 1])
        
        with col2:
            if st.button(
                "📤 Envoyer" if not st.session_state.is_streaming else "⏳ En cours...",
                disabled=not user_input.strip() or st.session_state.is_streaming,
                type="primary",
                use_container_width=True
            ):
                if user_input.strip():
                    # Clear the input
                    query = user_input.strip()
                    
                    # Stream the response
                    stream_response(query, st.session_state.current_thread_id)
                    
                    # Clear input and rerun
                    st.session_state.user_input = ""
                    st.rerun()

# Run the app
if __name__ == "__main__":
    main()